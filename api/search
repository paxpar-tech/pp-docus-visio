[{"id":"content:0.index.md","path":"/","dir":"","title":"Home","description":"","keywords":[],"body":"     Our vision of Docus present and future.   Our experiments with   Docus  to fit our needs\nin a very opiniated way.  Write pages in   Markdown , use   Vue  components and enjoy the power of   Nuxt .     Custom nuxt layer   bun  packet manager  Support PDF file type  Support exotic file type  S3 content backend  Nuxt Studio feedback  "},{"id":"content:1.introduction:1.getting-started.md","path":"/introduction/getting-started","dir":"introduction","title":"Getting Started","description":"","keywords":["TODO"],"body":"  Getting Started  TODO   exotic format : PDF  exotic format : FEC, ifc, XML, ...  k8s deployment  vue/nuxt/content/docus/studio  painfull JS/TS stack (yarn/pnpm/bun)  static/SSR/hybrid/SPA/... mess, hard to understand"},{"id":"content:10.docus:filter_ignore.md","path":"/docus/filter_ignore","dir":"docus","title":"Filter / Ignore","description":"YAML and JSON files are first class content payloads.","keywords":[],"body":"  Filter / Ignore  YAML and JSON files are first class content payloads.  But YAML and JSON files can also be   opaque  assets not related to content.\nWe may think this is not a trouble to let those files be consumed as content payloads.\nBut in some cases they may be big and will probably clutter the content engine.  We would like to define which YAML/JSON should be ignored by the content engine.  We would also like to define a filter for intermediate cases where we want to keep a small part of the JSON/YAML payload as content."},{"id":"content:10.docus:s3.md","path":"/docus/s3","dir":"docus","title":"S3 bucket","description":"","keywords":[],"body":"  S3 bucket   Use a S3 bucket as a nuxt content storage  Merge/mix nuxt content storage from filesystem and S3 bucket  Fetch nuxt content data from S3 bucket at runtime"},{"id":"content:10.docus:schema.md","path":"/docus/schema","dir":"docus","title":"$schema transform","description":"When defining a new content transformer\nwe tell which extensions are involved.","keywords":[],"body":"  $schema transform  When defining a   new content transformer \nwe tell which extensions are involved.  It's fine to target single purpose file formats like '.xlsx' or '.csv'.\nBut it's not enough to set up a transformer for a special YAML or JSON based dialect.  We can use custom extension like   .checklist.yaml  but it would be better to detect the thoses files without modifiyng them.  For JSON/YAML special dialects it is very common to use the   $schema property .   $schema  filter  Expected new YAML/JSON schema transformer :     export   default   defineJSONSchemaTransformer  ({\n     name:   'my-dummy-transformer'  ,\n     schema:   '$schema: https://paxpar.tech/schema/mycheck/default/0'  ,\n     extensions: [\n       '.yaml'  ,\n       '.yml'  ,\n       '.json'  ,\n     ],\n     // ...\n   })\n  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"},{"id":"content:10.docus:single_tree.md","path":"/docus/single_tree","dir":"docus","title":"Single Tree","description":"Let's have a single tree to organize all files related to content.","keywords":[],"body":"  Single Tree  Let's have a single tree to organize all files related to content.  Today we need to   separate  files in many folders:    /content  for files supported by nuxt content (md, json, yaml)   /public  for files not content aware (jpeg, wbep, svg, ...)  some other folders of many file types related to other part of the platform (API, business logic design docs, file samples, ...)  Example of multiple trees:   /\n├── content/\n│   ├── case1.md\n│   └── case2.md\n├── public/\n│   ├── case1/\n│   │   ├── check_step1.webp\n│   │   ├── check_step2.webp\n│   │   └── photo.webp\n│   └── case2/\n│       ├── check_step1.webp\n│       ├── check_step2.webp\n│       └── photo.webp\n└── pp-ref-common/\n    ├── customer1/\n    │   ├── case1.md\n    │   └── case2.md\n    └── customer2/\n        ├── case1.md\n        └── case2.md\n\n"},{"id":"content:30.nuxt_studio:1.components.md","path":"/nuxt_studio/components","dir":"nuxt_studio","title":"escape key","description":"While editing a file, pressing the escape key move up one level on editor/browser hierarchy.","keywords":[],"body":"  escape key  While editing a file, pressing the escape key move up one level on editor/browser hierarchy.  In the editor this beheviour is misleading if you use mutiple cursors.\nThe common way to exit multiple cursors is also pressing the escape key.  To be sure to exit the multiple cursors, I tend to press the escape key even if I'm not in multiple cursor, resulting in exiting the editor."},{"id":"content:30.nuxt_studio:2.composables.md","path":"/nuxt_studio/composables","dir":"nuxt_studio","title":"Composables","description":"Discover the Docus composables to use in your custom Vue components and pages.","keywords":["useDocus()","useMenu()","useScrollspy()"],"body":"  Composables  Discover the Docus composables to use in your custom Vue components and pages.   useDocus()    useDocus  ()\n  gives access to docus runtime config, all default values and your custom config from   app.config.ts    config  refers to the merged config of the current page.   main ,   header ,   aside ,   footer  and   titleTemplate  can be set from   _dir.yml  and any   page.md  file.  The configs in   app.config  file will be used as defaults.     <  script   setup  >\n   const   {   config   }   =   useDocus  ()\n   </  script  >\n   \n   <  template  >\n     <  div  >\n       <  h1  >{{ config.title }}</  h1  >\n       <  p  >{{ config.description }}</  p  >\n     </  div  >\n   </  template  >\n    tree  refers to the current navigation tree that is displayed in the   aside  component.     <  script   setup  >\n   const   {   tree   }   =   useDocus  ()\n   </  script  >\n   \n   <  template  >\n     <  DocsAsideTree   :links  =  \"tree\"   />\n   </  template  >\n    useMenu()   useMenu()  gives access to   $menu  plugin controlling mobile navigation globally.     const   {\n     // Is menu visible\n     visible  ,\n     // Close menu function\n     close  ,\n     // Open menu function\n     open  ,\n     // Toggle menu function\n     toggle\n   }   =   useMenu  ()\n    useScrollspy()   useScrollspy()  is used in   docs  layout to make the ToC display the currently visible headings.     const   {\n     // Headings on the page\n     visibleHeadings  ,\n     // Active headings (for the current page)\n     activeHeadings  ,\n     // Update headings (an array of DOM nodes)\n     updateHeadings\n   }   =   useScrollspy  ()\n   html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"},{"id":"content:30.nuxt_studio:json_schema.md","path":"/nuxt_studio/json_schema","dir":"nuxt_studio","title":"JSON-Schema","description":"Replicate the behaviour of the redhat YAML vscode extension.\nIt lets you validate your JSON or YAML content against a predefined schema.","keywords":[],"body":"  JSON-Schema  Replicate the behaviour of the   redhat YAML vscode extension .\nIt lets you validate your JSON or YAML content against a predefined   schema .  It's a life saver when you deal with strongly typed JSON/YAML content.  With a single first comment pointing to your schema, the editor will check if your content is valid :     # yaml-language-server: $schema=https://paxpar.gitlab.io/schemas/checklist-2.0.schema.json\n   $schema  :   https://paxpar.tech/schema/mycheck/default/0\n   name  :   Ordre d'intervention EDF\n   desc  :   Liste de vérification appliquée lors de la saisie d'un ordre d'intervention\n   tags  :\n     -   atelier\n   owner  :\n     signature_pubkey  :   default\n  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"}]